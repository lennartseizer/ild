---
title: "Preprocessing"
---

```{r, include=FALSE}
install.packages("dplyr")
install.packages("ggplot2")
install.packages("cowplot")
install.packages("tidyr")
install.packages("ggdist")
install.packages("forcats")
install.packages("scales")
```

Preprocessing can be organized along a reproducible workflow: (1) understand the study design, (2) reliably import the raw data, (3) validate measurement windows, (4) classify missing and problematic observations, (5) compute scales and derived variables, (6) generate the analysis dataset for the target model (e.g., LMM). Each step should be documented in scripts to ensure that the analyses remain transparent and reproducible. 

<figure>
    <img src="https://www.researchgate.net/profile/Sheen-Levine/publication/325941519/figure/fig2/AS:824194581422080@1573514709439/The-Datasaurus-Dozen-Matejka-Fitzmaurice-2017-an-extension-of-Anscombes-quartet.ppm">
    <figcaption>The Datasaurus Dozen: All of them have identical descriptive statistics (Matejka & Fitzmaurice, 2017).
  </figcaption>
</figure>

# Get data

```{r, message=FALSE}
# set environment
library(dplyr)
library(ggplot2)
library(cowplot)
library(tidyr)
library(forcats)
library(ggdist)
library(scales)
```

```{r, message=FALSE}
# load example data
data <- read.delim("https://www.kuleuven.be/samenwerking/real/real-book/viechtbauer2022_data_esmda_example")

str(data)
```

**Design variables**: the study `day` (1 to 6), the `beep` number within
each day (1 to 10) and `beeptime` (in minutes after midnight) on each day, the overall number of observations `obs` (1 to 60), the response time `resptime` (in minutes after midnight)

**Subject-level, time-invariant variables**: the participants' `age` (in years), `sex` (female, male), and mental
health `status` (control, depressed, psychotic)  

**Time-varying response variables**: 3 items to assess positive affect and 6 items to assess negative affect (1 to 7 Likert scale), the pleasantness of events that had occurred since the previous beep `eventpl` (−3 to +3 bipolar scale), whether the person was alone at the time of the beep `soc_alone` (1 = alone, 0 = not alone) and when the person was not alone) a rating how pleasant the company is `soc_pleasant` (1 to 7 Likert scale), and whether they had consumed coffee / alcohol since the previous beep (1 = yes, 0 = no)

<figure>
    <img src="https://carpentry.library.ucsb.edu/2023-01-23-ucsb-r/fig/14-tidyr-fig3.png">
</figure>

# Design and sampling scheme

```{r}
# number of participants
length(unique(data$id))

# number of planned observations 
nrow(data)
```

```{r}
# missing values in design variables?
design_vars <- c("id", "day", "beep", "beeptime", "obs")

data %>%
  summarise(across(all_of(design_vars), ~ any(is.na(.))))
```

```{r, message=FALSE}
# no variance in time-invariant variables?
l2_vars <- c("age", "sex", "status")

data %>%
  group_by(id) %>%
  summarise(across(all_of(l2_vars), ~ n_distinct(.) == 1), 
            .groups = "drop") %>%
  summarise(across(all_of(l2_vars), all))
```

# Participants response behaviors

```{r, fig.dim = c(10, 4)}
# compute the response frequencies
data$compl <- !is.na(data$resptime)

# histogram of the response frequencies
p_comp1 <- ggplot(aggregate(data, compl ~ id, sum), aes(x = compl)) +
  geom_bar() + 
  labs(title = "Response Frequency", 
       x = "Number of assessments") +
  theme_bw(base_size = 12) +
  theme(plot.title = element_text(face = "bold"),
        legend.position = "none")

# histogram of the compliance
p_comp2 <- ggplot(aggregate(data, compl ~ id, sum), 
                  aes(x = compl / 60 * 100)) + 
  geom_bar() + 
  labs(title = "Response Frequency", 
       x = "Percentage of assessments") +
  theme_bw(base_size = 12) +
  theme(plot.title = element_text(face = "bold"),
        legend.position = "none")

plot_grid(p_comp1, p_comp2)

# summary of compliance
summary(aggregate(data, compl ~ id, sum)$compl / 60 * 100)
```

```{r, fig.dim = c(5, 4), out.width="50%", warning=F}
# compute response delays
data$delay <- data$resptime - data$beeptime

# barplot of the delay 
ggplot(data, aes(x = delay)) + geom_bar() +
  labs(title = "Delay of responses to beeps") +
  theme_bw(base_size = 12) +
  theme(plot.title = element_text(face = "bold"),
        legend.position = "none")
```

# Compute and transform variables

```{r, warning=F, fig.dim = c(10, 8)}
# check distributions and out-of-range values
hist1 <- ggplot(data, aes(x = mood_relaxed)) + geom_bar() + 
            theme_bw() + ggtitle("Mood: Relaxed") 

hist2 <- ggplot(data, aes(x = mood_down)) + geom_bar() + 
            theme_bw() + ggtitle("Mood: Down")

hist3 <- ggplot(data, aes(x = eventpl)) + geom_bar() + 
            theme_bw() + ggtitle("Event pleaseantness")

hist4 <- ggplot(data, aes(x = age)) + geom_bar() + 
            theme_bw() + ggtitle("Age")

plot_grid(hist1, hist2, hist3, hist4)
```

```{r}
# summary of L2-variables
head(aggregate(data, age ~ id, unique))
```

```{r}
# compute scales of positive and negative affect
data$pa <- rowMeans(data[,c("mood_cheerf", "mood_relaxed", 
                            "mood_satisfi")])

data$na <- rowMeans(data[,c("mood_irritat", "mood_anxious", 
                            "mood_down", "mood_guilty", 
                            "mood_insecur", "mood_lonely")])
```

```{r}
# separate variables into within and between parts 
# (event pleasantness)

# compute person-means 
data$eventpl_b <- ave(data$eventpl, data$id, 
                      FUN = function(x) mean(x, na.rm = TRUE)) 

# person-mean centering
data$eventpl_w <- data$eventpl - data$eventpl_b 

# compute grand-mean 
eventpl_gm <- mean(aggregate(data, eventpl_b ~ id, unique)$eventpl_b)

# person-mean centering
data$eventpl_bc <- data$eventpl_b - eventpl_gm

head(data[, c("id", "day", "beep", "eventpl","eventpl_b", 
              "eventpl_w", "eventpl_bc")])
```

```{r, fig.dim = c(5, 4), out.width="50%", warning=F}
# plot between part of event_pl
id_select <- unique(data$id)[1:20]

data %>% filter(id %in% id_select) %>%
  ggplot(aes(x = obs, y = eventpl_b, col = id)) +
     geom_hline(yintercept = eventpl_gm, lty = "dashed", lwd = 1) +
     geom_line() + 
     labs(title = "Between-part of eventpl") +
     theme_bw(base_size = 12) +
     theme(plot.title = element_text(face = "bold"),
           legend.position = "none")
```

```{r, fig.dim = c(10, 8), warning=F}
# plot within part of event_pl
id_select <- unique(data$id)[1:20]

data %>% filter(id %in% id_select) %>%
  ggplot(aes(x = obs, y = eventpl_w, col = id)) +
     geom_line() + geom_point(size = 1) + facet_wrap(~id) +
     labs(title = "Within-part of eventpl") +
     theme_bw(base_size = 12) +
     theme(plot.title = element_text(face = "bold"),
           legend.position = "none")
```

```{r}
# create lagged variables
data <- data %>%
  arrange(id, obs) %>%                
  group_by(id) %>%     
  # lag by 1 obs
  mutate(eventpl_w_l1 = lag(eventpl_w, n = 1)) %>% 
  # reset each day
  mutate(eventpl_w_l1 = if_else(beep == 1, NA, eventpl_w_l1)) %>%
  ungroup()

head(data[, c("id", "day", "beep", "eventpl_w", "eventpl_w_l1")], 
     n = 25)
```

# Visualization

```{r, fig.dim = c(10, 8), warning=F}
# plot PA time series in chunks of participants
id_select <- unique(data$id)[1:20]

data %>% filter(id %in% id_select) %>%
  ggplot(aes(x = obs, y = pa, col = id)) +
     geom_line() + geom_point() + facet_wrap(~id) +
     theme_bw() + theme(legend.position = "none")
```

**Plot individual means of participants for all mood items**
```{r, fig.dim = c(10, 8), warning=F}
# boxplots of individual means per item

# select items
item_select <- c("mood_cheerf", "mood_relaxed", "mood_irritat", "mood_anxious",
                 "mood_down", "mood_guilty", "mood_insecur", "mood_lonely")

# person means per item 
person_means <- data %>%
  select(id, all_of(item_select)) %>%
  pivot_longer(-id, names_to = "item", values_to = "score") %>%
  group_by(id, item) %>%
  summarise(iMean = mean(score, na.rm = TRUE), .groups = "drop") %>%
  tidyr::drop_na(iMean) 

# plot
ggplot(person_means, aes(x = iMean, y = item, col = item)) +
  geom_jitter(height =.2, alpha = 0.6) +
  geom_boxplot( width = 0.12, outlier.shape = NA,color = "grey20") +
  scale_x_continuous(breaks = 1:7) +
  labs(title = "Boxplots for mood items", y = NULL,
       x = "Individual mean") +
  theme_bw(base_size = 12) +
  theme(plot.title = element_text(face = "bold"),
        legend.position = "none")
```

**Plot mood item responses across settings (alone & location)**
```{r, fig.dim = c(10, 8), warning=F}
# choose items
pos <- c("mood_cheerf","mood_relaxed","mood_satisfi")

# create combinations of settings
data %>%
    select(soc_alone, location, all_of(pos)) %>%
    tidyr::pivot_longer(all_of(pos), names_to="item", values_to="score") %>%
    tidyr::drop_na(score, soc_alone, location) %>%
    mutate(combo=paste(if_else(soc_alone==1,"Alone","Not alone"),
                       if_else(grepl("home",tolower(location)),"& Home","& Other")),
           resp=factor(pmin(pmax(round(score),1),7), levels=1:7)) %>%

# plot  
  ggplot(aes(x=combo, fill=resp)) +
  geom_bar(position="fill") + coord_flip() +
  facet_wrap(~item, nrow=1) +
  scale_y_continuous(labels=scales::percent) + 
  labs(title = "Mood across settings", x = NULL,
       y = "Relative frequency") +
  theme_bw(base_size = 12) +
  theme(plot.title = element_text(face = "bold"))
```

**Plot mood item means over time of day**
```{r}
# select items
items <- c("mood_cheerf","mood_relaxed","mood_satisfi",
           "mood_irritat","mood_anxious","mood_down",
           "mood_guilty","mood_insecur","mood_lonely")

# create summary stats across beeps
sumdat <- data %>%
    select(beep, all_of(items)) %>%
    pivot_longer(all_of(items), names_to="item", values_to="score") %>%
    drop_na(beep, score) %>%
    group_by(item, beep) %>%
    summarise(mean = mean(score, na.rm=TRUE),
              se   = sd(score, na.rm=TRUE)/sqrt(sum(!is.na(score))),
              .groups="drop")

# plot
ggplot(sumdat, aes(x = beep, y = mean, color = item)) +
    geom_line() + geom_point(size = 1.5) +
    geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0) +
    scale_x_continuous(breaks = sort(unique(sumdat$beep))) +
    labs(title = "Item means across beeps (time of day)",
         x = "Beep", y = "Mean response", color = "Item") +
    theme_bw(base_size = 12) +
    theme(panel.grid.minor = element_blank())
```

**Plot mood item means over study days**
```{r}
# select items
items <- c("mood_cheerf","mood_relaxed","mood_satisfi",
           "mood_irritat","mood_anxious","mood_down",
           "mood_guilty","mood_insecur","mood_lonely")

# create summary stats across days
sumdat <- data %>%
  select(day, all_of(items)) %>%
  pivot_longer(all_of(items), names_to="item", values_to="score") %>%
  drop_na(day, score) %>%
  group_by(item, day) %>%
  summarise(mean = mean(score, na.rm=TRUE),
            se   = sd(score, na.rm=TRUE)/sqrt(sum(!is.na(score))),
            .groups="drop")

# plot
ggplot(sumdat, aes(x = day, y = mean, color = item)) +
  geom_line() + geom_point(size = 1.5) +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0) +
  scale_x_continuous(breaks = sort(unique(sumdat$day))) +
  labs(title = "Item means across study days",
       x = "Day", y = "Mean response", color = "Item") +
  theme_bw(base_size = 12) +
  theme(panel.grid.minor = element_blank())
```

**Plot participants based on average PA level**
```{r, fig.dim = c(10, 4), warning=F}
# compute within-id PA mean
pa_level <- data %>%
  group_by(id) %>%
  summarise(pa_mean = mean(pa, na.rm = TRUE), .groups = "drop") %>%
  filter(is.finite(pa_mean))

# select targets
qs <- quantile(pa_level$pa_mean, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE, type = 7)
targets <- tibble(
  which  = c("0th","25th","50th","75th","100th"),
  target = as.numeric(qs)
)

# pick the id whose mean is closest 
remaining <- pa_level
picked <- vector("list", nrow(targets))
for (i in seq_len(nrow(targets))) {
  if (nrow(remaining) == 0) break
  chosen <- remaining %>%
    mutate(diff = abs(pa_mean - targets$target[i])) %>%
    arrange(diff, pa_mean, id) %>%   
    slice(1) %>%
    mutate(which = targets$which[i]) %>%
    select(id, pa_mean, which)
  picked[[i]] <- chosen
  remaining <- remaining %>% filter(id != chosen$id)
}
id_select_tbl <- bind_rows(picked) %>% distinct()

id_select_tbl <- id_select_tbl %>%
  arrange(pa_mean) %>%
  mutate(panel = paste0(which, ": ", id, " (Mean=", round(pa_mean, 2), ")"),
         panel = factor(panel, levels = panel))

# plot the selected IDs 
data %>%
  semi_join(id_select_tbl, by = "id") %>%
  left_join(id_select_tbl %>% select(id, panel), by = "id") %>%
  arrange(id, obs) %>%
  ggplot(aes(x = obs, y = pa, group = id)) +
  geom_line() +
  geom_point() +
  facet_wrap(~ panel, nrow = 1) +
  labs(
    title = "PA time series at 1th, 25th, 50th, 75th, and 100th percentiles of within-id Mean",
    x = "Observation", y = "PA"
  ) +
  theme_bw(base_size = 12) +
  theme(legend.position = "none")
```

**Plot participants based on PA variability**
```{r, fig.dim = c(10, 4), warning=F}
# compute PA variability (SD)
pa_var <- data %>%
  group_by(id) %>%
  summarise(pa_sd = sd(pa, na.rm = TRUE), .groups = "drop") %>%
  filter(is.finite(pa_sd))

# select targets
qs <- quantile(pa_var$pa_sd, probs = c(0, 0.25, 0.5, 0.75, 1), na.rm = TRUE, type = 7)
targets <- tibble(
  which  = c("0th","25th","50th","75th","100th"),
  target = as.numeric(qs)
)

# pick the id whose SD is closest 
remaining <- pa_var
picked <- vector("list", nrow(targets))
for (i in seq_len(nrow(targets))) {
  if (nrow(remaining) == 0) break
  chosen <- remaining %>%
    mutate(diff = abs(pa_sd - targets$target[i])) %>%
    arrange(diff, pa_sd, id) %>%  
    slice(1) %>%
    mutate(which = targets$which[i]) %>%
    select(id, pa_sd, which)
  picked[[i]] <- chosen
  remaining <- remaining %>% filter(id != chosen$id)
}
id_select_tbl <- bind_rows(picked) %>% distinct()

id_select_tbl <- id_select_tbl %>%
  arrange(pa_sd) %>%
  mutate(panel = paste0(which, ": ", id, " (SD=", round(pa_sd, 2), ")"),
         panel = factor(panel, levels = panel))

# plot the selected IDs 
data %>%
  semi_join(id_select_tbl, by = "id") %>%
  left_join(id_select_tbl %>% select(id, panel), by = "id") %>%
  arrange(id, obs) %>%
  ggplot(aes(x = obs, y = pa, group = id)) +
  geom_line() +
  geom_point() +
  facet_wrap(~ panel, nrow = 1) +
  labs(
    title = "PA time series at 0th, 25th, 50th, 75th, and 100th percentiles of within-id SD",
    x = "Observation", y = "PA"
  ) +
  theme_bw(base_size = 12) +
  theme(legend.position = "none")
```

# References & Further reading

Matejka, J., & Fitzmaurice, G. (2017). Same stats, different graphs: generating datasets with varied appearance and identical statistics through simulated annealing. In Proceedings of the 2017 CHI conference on human factors in computing systems (pp. 1290-1294).

Siepe, B. S., Rieble, C. L., Tutunji, R., Rimpler, A., März, J., Proppert, R. K., & Fried, E. I. (2025). Understanding Ecological-Momentary-Assessment Data: A Tutorial on Exploring Item Performance in Ecological-Momentary-Assessment Data. Advances in Methods and Practices in Psychological Science, 8(1), 25152459241286877.


# References & Further reading

Matejka, J., & Fitzmaurice, G. (2017). Same stats, different graphs: generating datasets with varied appearance and identical statistics through simulated annealing. In Proceedings of the 2017 CHI conference on human factors in computing systems (pp. 1290-1294).
